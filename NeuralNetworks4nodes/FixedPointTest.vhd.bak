library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.fp_pkg.all;

entity simple1 is
end entity simple1;
architecture tb of simple1 is
signal clk : std_logic := '0';
signal cin : std_logic := '0';
signal cout : std_logic;
signal testa : fp8_3 := "000000000000";
signal testa1 : fixsign ( 8 downto -3 );
signal testa2 : fixsign ( 8 downto -3 );
signal testb1 : fixsign ( 8 downto -3 );
signal testsum : fixsign ( 8 downto -3 );
signal as : signed ( 11 downto 0) := X"000";
signal a1std : std_logic_vector ( 11 downto 0) :=
X"800";
signal b1std : std_logic_vector ( 11 downto 0) :=
X"800";
signal sum : std_logic_vector ( 11 downto 0) ;
signal a1out : real;
signal b1out : real;
signal a2out : real;
signal sumout : real;
signal a1 : integer := 0;
signal bs : signed ( 11 downto 0) := X"8f0";
component add_beh
generic (
top : integer := 7
);
port (
signal a : in std_logic_vector(top
downto 0);
signal b : in std_logic_vector(top
downto 0);
signal cin : in std_logic;
signal cout : out std_logic;
signal sum : out std_logic_vector(top
downto 0)
);
end component;
for all : add_beh use entity work.add_beh;
begin
clk <= not clk after 1 us;
DUT :add_beh generic map ( 11 ) port map ( a1std,
b1std, cin, cout, sum);
p1 : process (clk)
begin
as <= as + 1;
testa1 <= signed2fp(as,8,-3);
testb1 <= signed2fp(bs,8,-3);


a1out <= fp2real(testa1,8,-3);
b1out <= fp2real(testb1,8,-3);
a1std <= fp2std_logic_vector(testa1,8,-3);
b1std <= fp2std_logic_vector(testb1,8,-3);
testa2 <= std_logic_vector2fp(a1std,8,-3);
testsum <= std_logic_vector2fp(sum,8,-3);
a2out <= fp2real(testa2,8,-3);
sumout <= fp2real(testsum,8,-3);
report "a1out : " & real'image(a1out);
report "a2out : " & real'image(b1out);
report "sumout : " & real'image(sumout);
end process p1;
end;

